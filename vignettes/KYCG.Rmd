---
title: "knowYourCG"
shorttitle: "KYCG"
package: knowYourCG
output: rmarkdown::html_vignette
fig_width: 6
fig_height: 5
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{"5. knowYourCG"}
  %\VignetteEncoding{UTF-8}
---

An automated discovery tool for discovering hidden biological and technical
links

# Quick start

knowYourCG is a tool for evaluating CpG feature enrichment using Illumina probe
IDs. Tthis tool automates the hypothesis testing by asking whether a set of
CpGs (indexed by Illumina methylation chip IDs, hence a sparse representation
of the methylome) is enriched in certain categories or features. These
categories or features can be categorical (e.g., CpGs located at specific
tissue-specific transcription factors) or continuous (e.g., the local CpG
density of CpGs). Additionally, the set of CpGs to which the test will be
applied can be categorical or continuous as well.

The set of CpGs that will be tested for enrichment is called the query set, and
the set of CpGs that will be used to determine enrichment is called the
database set. A query set, for example, might be the results of a differential
methylation analysis or from an epigenome-wide association study. We have taken
the time to curate our own database sets from a variety of sources that
describe different categorical and continuous features such as technical
characterization of the probes, CpGs associated with certain chromatin states,
gene association, transcription factor binding sites, CpG density, etc.

Additionally, knowYourCG has support for feature selection and feature
engineering, which is currently in development.

The following commands prepares the use of KnowYourCG:

```{r load-depenencies, results="hide", message=FALSE, warning=FALSE}
library(sesame)
sesameDataCache()
```

Our example uses a specific mouse design group as input (PGCMeth, methylated in
primoridal germ cells). First get the CG list using the following code:

```{r message=FALSE}
query <- KYCG_getDBs("MM285.designGroup")[["PGCMeth"]]
head(query)
```

Now test the enrichment over database groups. By default, KYCG will select all
the categorical groups and overlapping genes (CpGs associated with a gene).

```{r fig.width=8, fig.height=5, message=FALSE}
results_pgc <- testEnrichment(query)
head(results_pgc)
```

We can visualize the result of this test using the `KYCG_plotEnrichAll`
function:

```{r}
KYCG_plotEnrichAll(results_pgc)
```

This plot groups different database sets along the x-axis and plot -log10(FDR)
on the y-axis. As expected, the PGCMeth group itself appear on the top of the
list. But one can also find histone H3K9me3, chromHMM `Het` and transcription
factor `Trim28` binding enriched in this CG group.

# Test enrichment

## Databases

The success of enrichment testing depends critically on the availability of
biologically-relevant databases. To reflect the biological meaning of databases
and facilitate selective testing, we have organized our database sets into
different groups. Each group contains one or multiple databases. Here is how to
find the names of pre-built database groups:

``` {r list-data, eval=TRUE, echo=TRUE}
KYCG_listDBGroups("MM285")
```

The `KYCG_listDBGroups()` function returns a data frame containing information
of these databases. The Title column is the accession key one needs for the
`testEnrichment` function.  With the accessions, one can either directly use
them in the `testEnrichment` function or explicitly call the
```KYCG_getDBs()``` function to retrieve databases themselves. Caching these
databases on the local machine is important, for two reasons: it limits the
number of requests sent to the Bioconductor server, and secondly it limits the
amount of time the user needs to wait when re-downloading database sets. For
this reason, one should run ```sesameDataCache()``` before loading in any
database sets. This will take some time to download all of the database sets
but this only needs to be done once per installation.  During the analysis the
database sets can be identified using these accessions. Sesame also does some
guessing when a unique substring is given. For example, the following
"MM285.designGroup" retrieves the "KYCG.MM285.designGroup.20210210"
database. Let's look at the database group which we had used as the query
(query and database are reciprocal) in our first example:

``` {r cache-data, eval=TRUE, warning=FALSE}
dbs <- KYCG_getDBs("MM285.design")
```

In total, 32 datasets have been loaded for this group. We can get the "PGCMeth"
as a list element:

``` {r view-data1, eval=TRUE, warning=FALSE}
str(dbs["PGCMeth"])
```

On subsequent runs of the ```KYCG_getDBs()``` function, the database loading
can be faster thanks to the sesameData [in-memory
caching](https://tinyurl.com/2wh9tyzk), if the corresponding database has been
loaded.

## The query set

A query set represents probes of interest. It may either be in the form of a
character vector where the values correspond to probe IDs or a named numeric
vector where the names correspond to probe IDs. The query and database
definition is rather arbitrary. One can regard a database as a query and turn a
query into a database, like in our first example. In real world scenario, query
can come from differential methylation testing, unsupervised clustering,
correlation with a phenotypic trait, and many others. For example, we could
consider CpGs that show tissue-specific methylation as the query. We are
getting the B-cell-specific hypomethylation.

```{r message=FALSE}
library(SummarizedExperiment)
df <- rowData(sesameDataGet('MM285.tissueSignature'))
query <- df$Probe_ID[df$branch == "B_cell"]
head(query)
```

This query set represents hypomethylated probes in Mouse B-cells from the MM285
platform. This specific query set has 168 probes.

# Four testing scenario

There are four testing scenarios depending on the type format of the query set
and database sets. They are shown with the respective testing scenario in the
table below. `testEnrichment`, `testEnrichmentGSEA` are for Fisher's exact test
and GSEA respectively.

```{r echo = FALSE, results="asis"}
library(knitr)
df = data.frame(
    "Continuous DB"=c("Correlation","GSEA"),
    "Discrete DB"=c("GSEA","Fisher's Exact Test"))
rownames(df) = c("Continuous Query", "Discrete Query")
kable(df, caption="Four KnowYourCG Testing Scenarios")
```

# The testEnrichment function

The main work horse function for test enrichment of a categorical query against
categorical databases is **testEnrichment** (surprise). This function
calculates the extent of overlap and apply different statistics for enrichment
testing. The ```testEnrichment()``` will perform Fisher's exact test
(one-tailed by default, but two-tailed optionally) and report metrics about
each of the the loaded database sets.

> **Choice of universal set:** Universal set is the set of all probes for a
given platform. It can either be passed in as an argument called
```universeSet``` or the platform name can be passed with argument
```platform```. If neither of these are supplied, the universe set will be
implied from the probes.

```{r run-test-single, echo=TRUE, eval=TRUE}
df <- rowData(sesameDataGet('MM285.tissueSignature'))

query <- df$Probe_ID[df$branch == "fetal_brain" & df$type == "Hypo"]
results <- testEnrichment(query, "TFBS")
results %>% dplyr::filter(overlap>10) %>% head

query <- df$Probe_ID[df$branch == "fetal_liver" & df$type == "Hypo"]
results <- testEnrichment(query, "TFBS")
results %>% dplyr::filter(overlap>10) %>%
    dplyr::select(dbname, estimate, test, FDR) %>% head
```

The output of each test contains at least four variables: the estimate (fold
enrichment, not the test statistics), p-value, type of test, and whether meta
data is included in the tested database set (hasMeta), as well as the name of
the database set and the database group. By default, the estimate column is
sorted.

It should be noted that the estimate (or test statistic) is test dependent and
comparison between p-values should be limited to within the same type of
test. For instance, the test statistics for Fisher's exact test and GSEA are
log fold change and the test statistic for Spearman's test is simply the rank
order correlation coefficient. For simplicity, we report all of the test types
in one data frame.

The ```nQ``` and ```nD``` columns identify the length of the query set and the
database set, respectively. Often, it's important to examine the extent of
overlap between the two sets, so that metric is reported as well in the
```overlap``` column.

We can visualize the results in a dot plot:

```{r fig.width=5, fig.height=3.5}
KYCG_plotDot(results, n_max=20)
```

or a bar plot:

```{r fig.width=6.5, fig.height=4, message=FALSE}
KYCG_plotBar(results, n_max=15)
```
 
or a volcano plot. Here we need a two-tailed test to show both enrichment and
depletion (the default is one-tailed):

```{r fig.width=6, fig.height=4, warning=FALSE}
query <- df$Probe_ID[df$branch == "fetal_brain" & df$type == "Hypo"]
results_2tailed <- testEnrichment(query, "TFBS", alternative = "two.sided")
KYCG_plotVolcano(results_2tailed)
```

and a Waterfall plot:

```{r fig.width=6, fig.height=4.5}
KYCG_plotWaterfall(results)
```

If you have a list of cg groups and they were tested against the same set of
databases, you can make a point range plot to summarize the overall trend:

```{r fig.width=3.5, fig.height=4}
## pick some big TFBS-overlapping CpG groups
cg_lists <- KYCG_getDBs("MM285.TFBS", silent=TRUE)
queries <- cg_lists[(sapply(cg_lists, length) > 40000)]
res <- lapply(queries, function(q) {
    testEnrichment(q, "MM285.chromHMM", silent=TRUE)})

## note the input of the function is a list of testEnrichment outputs.
KYCG_plotPointRange(res)
```

Here we picked some transcription factor binding sites-overlapping CpGs and
tested against chromHMM states. As expected, most of these CGs are enriched at
promoters and enhancers but depleted at heterchromatic regions.

# Gene enrichment

Automating the enrichment test process only works when the number of database
sets is small. This is important when targeting all genes as there are tens of
thousands of genes on each platform. By testing only those genes that overlap
with the query set, we can greatly reduce the number of tests. For this reason,
the gene enrichment analysis is a special case of these enrichment tests. We
can perform this analysis using the ```KYCG_buildGeneDBs()``` function.

```{r fig.width=7, fig.height=6, echo=TRUE, warning=FALSE}
query <- names(sesameData_getProbesByGene("Dnmt3a", "MM285"))
results <- testEnrichment(query, KYCG_buildGeneDBs(query, max_distance=100000))
results[,c("dbname","estimate","gene_name","FDR", "nQ", "nD", "overlap")]
```

Using these sample results, we can plot a volcano plot and lollipop plot.

```{r fig.width=5, fig.height=4, echo=TRUE}
KYCG_plotLollipop(results, label="gene_name")
```

As expected, we recover our targeted gene (Dnmt3a).

# GO/Pathway enrichment

One can get all the genes associated with a probe set by

```{r}
df <- rowData(sesameDataGet('MM285.tissueSignature'))
query <- df$Probe_ID[df$branch == "fetal_liver" & df$type == "Hypo"]
genes <- sesameData_getGenesByProbes(query)
genes
```

Here we demonstrate the use of
[g:Profiler2](https://biit.cs.ut.ee/gprofiler/gost) to perform Gene ontology
enrichment analysis:

```{r eval = FALSE}
library(gprofiler2)

## use gene name
gostres <- gost(genes$gene_name, organism = "mmusculus")
gostres$result[order(gostres$result$p_value),]
gostplot(gostres)

## use Ensembl gene ID, note we need to remove the version suffix
gene_ids <- sapply(strsplit(names(genes),"\\."), function(x) x[1])
gostres <- gost(gene_ids, organism = "mmusculus")
gostres$result[order(gostres$result$p_value),]
gostplot(gostres)
```

# Meta gene enrichment

KnowYourCG builds in several metagene/meta-feature coordinates. One can test
enrichment over meta genes or simply plot the mean over metagenes:

```{r plot-meta1, fig.width=5, fig.height=4}
sdf <- sesameDataGet("EPIC.1.SigDF")
KYCG_plotMeta(getBetas(sdf))
```

# GSEA

The query may be a named continuous vector. In that case, either a gene
enrichment score will be calculated (if the database is discrete) or a Spearman
correlation will be calculated (if the database is continuous as well). The
three other cases are shown below using biologically relevant examples.

To display this functionality, let's load two numeric database sets
individually. One is a database set for CpG density and the other is a database
set corresponding to the distance of the nearest transcriptional start site
(TSS) to each probe.

```{r run-test-data, echo=TRUE, eval=TRUE}
query <- KYCG_getDBs("KYCG.MM285.designGroup")[["TSS"]]
```

```{r echo=TRUE, eval=TRUE, message=FALSE}
res <- testEnrichmentGSEA(query, "MM285.seqContextN")
res[, c("dbname", "test", "estimate", "FDR", "nQ", "nD", "overlap")]
```

The estimate here is enrichment score.

> **NOTE:** Negative enrichment score suggests enrichment of the categorical
database with the higher values (in the numerical database). Positive
enrichment score represent enrichment with the smaller values. As expected, the
designed TSS CpGs are significantly enriched in smaller TSS distance and higher
CpG density.

Alternatively one can test the enrichment of a continuous query with discrete
databases. Here we will use the methylation level from a sample as the query
and test it against the chromHMM chromatin states.

```{r warning=FALSE}
beta_values <- getBetas(sesameDataGet("MM285.1.SigDF"))
res <- testEnrichmentGSEA(beta_values, "MM285.chromHMM")
res[, c("dbname", "test", "estimate", "FDR", "nQ", "nD", "overlap")]
```

As expected, chromatin states `Tss`, `Enh` has negative enrichment score,
meaning these databases are associated with small values of the query (DNA
methylation level). On the contrary, `Quies` states are associated with high
methylation level.

# Feature engineering

In addition to hypothesis testing, knowYourCG also uses the curated database
sets for feature engineering. We have a pre-curated summarized experiment
containing a samplesheet and beta value matrix corresponding to about 467 MM285
samples with 20k probes. The samplesheet includes UIDs pertaining to the sample
and several categorical/numerical features. To use this data for a linear
model, we will extract the most relevant prevalent features.

``` {r run-feature-engineering-get-data, echo=TRUE, eval=TRUE}
library(SummarizedExperiment)
betas = assay(sesameDataGet('MM285.20Kx467.SE'))
```

We have found that it is computationally expensive to perform a linear
model/generalized linear model on a feature set of individual
CpGs. Additionally, interpreting the mechanism the significantly contributing
CpGs is non-trivial due to their complex interactions. We hope to leverage
these pre-curated database sets by using their beta value summary statistics as
features instead. We will calculate the summary statistics for the betas matrix
using a list of database sets. The default is to calculate the mean.

```{r run-feature-engineering-statistics}
stats <- dbStats(betas, 'MM285.chromHMM')
head(stats[, 1:5])
```

Just from the few database set means above, we can see that TSS are
consistently hypomethylated, which is consistent with known biology.

```{r fig.width=6, fig.height=6}
library(wheatmap)
WHeatmap(both.cluster(stats)$mat, xticklabels=TRUE,
    cmp=CMPar(stop.points=c("blue","yellow")))
```

# Session Info

```{r}
sessionInfo()
```
