---
title: "SeSAMe Basic Usage"
date: "`r BiocStyle::doc_date()`"
package: sesame
output: BiocStyle::html_document
fig_width: 6
fig_height: 6
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{"0. Basic Usage"}
  %\VignetteEncoding{UTF-8}
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library(sesame)
library(dplyr)
options(rmarkdown.html_vignette.check_title = FALSE)
```

# Installation

To install SeSAMe from Bioconductor,
```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("sesame")
```

To install the development version directly from github
```{r, eval=FALSE}
BiocManager::install('zwdzwd/sesameData')
BiocManager::install('zwdzwd/sesame')
```

If you install directly from github, you need to make sure the compatible
ExperimentHub is installed.

**CRITICAL:** After a new installation, one needs to cache the associated
annotation data using the following command.
This needs to be done only once per SeSAMe installation.

```{r}
sesameDataCacheAll()
```

This function caches the needed SeSAMe annotation for all the supported
platforms. SeSAMe annotation data is managed by the
[sesameData](https://bioconductor.org/packages/release/data/experiment/html/sesameData.html)
package which is based on the
[ExperimentHub](https://bioconductor.org/packages/release/bioc/html/ExperimentHub.html) package.
You can find the location of the cached annotation data on
your local computer using:

```{r}
tools::R_user_dir("ExperimentHub", which="cache")
```

You can verify the version of the installed sesame and ExperimentHub

```{r}
packageVersion("sesame")
packageVersion("ExperimentHub")
```

# Read IDATs

The raw Infinium BeadChip data are stored in IDAT files. Each sample has
two IDAT files and they correspond to the red and green signal respectively.
Green and red files for the same samples should always share the same sample
name prefix.
For example, `204529320035_R06C01_Red.idat` and
`204529320035_R06C01_Grn.idat` correspond to the red and green signal
of one sample. In SeSAMe, we will use the **common prefix**,
i.e. `204529320035_R06C01`, to refer to that sample.
SeSAMe recognizes both the raw IDAT as well as gzipped IDATs which are common
for data stored in [GEO](https://www.ncbi.nlm.nih.gov/geo/).
For example, in addition to the example above, SeSAMe also recognizes
`GSM2178224_Red.idat.gz` and `GSM2178224_Grn.idat.gz`.

The function `readIDATpair` function reads in the signal intensity data from
the IDAT pairs. The function takes the **common prefix** as input and outputs a
`SigDF` object. The `SigDF` object is simply an R data.frame with rows
representing probes and columns different signal intensity and probe
annotations. The `SigDF` class will be discussed more below. Using the two
examples above, one would run the following commands.

```{r eval=FALSE}
sdf = readIDAT("204529320035_R06C01")  # Example 1
sdf = readIDAT("GSM2178224")           # Example 2
```

Note that SeSAMe automatically detects and matches up the green and red signal
files for the same sample. One can summarize resulting `SigDF` using the
'sesameQC_calcStats' function. More QC can be found in [the quality control
vignette](QC.html).

```{r}
sdf = sesameDataGet('EPIC.1.SigDF') # an example SigDF
head(sdf) # peek into the internals
sesameQC_calcStats(sdf, "numProbes")
```

We will get back to the structure of `SigDF` below.

# Custom Arrays

If you are dealing with a custom-made array instead of the standard array
(MM285, EPIC, HM450 etc) supported natively by SeSAMe, you would need to
provide a manifest that describe the probe information. You should be able to
obtain that from the Illumina support website.  The manifest should be made
into a simple data frame with a minimum of four columns: `Probe_ID`, `M`, `U`
and `col`. The easiest way to format the the manifest os that it is compatible
with SeSAMe is by following internal manifests for a SeSAME-supported
platform. They can be retrieved with the `sesameDataGet` function:

```{r}
mft = sesameDataGet("MM285.address")$ordering
```

The `col` is either `G` (stand for Green) or `R` (stand for Red) or `2` (
stand for both in the case of Infinium II design).
For Infinium-II probes, the `M` column and `col` column is left to be `NA`.
For example, one can check that both `M` and `col` columns are filled with
the Infinium-I probes:
```{r}
head(mft[!is.na(mft$col),])
```
The last column `mask` is a logical vector that defines the default masking
behavior of SeSAMe for the platform (see below for discussion of NA-masking).

With the manifest, your data can be processed using
```{r eval = FALSE}
sdf = readIDATpair("your_sample_name", manifest = mft)
betas = getBetas(sdf)
```

# Search IDAT Prefixes

Most often we will be working with a folder that contains many IDATs. Here is
where the `searchIDATprefixes` function comes in handy. It lets us search all
the IDATs in a folder and its subfolders recursively. Combine this with the
R looping functions lets you process many IDATs without having to specify
all IDAT names. `searchIDATprefixes` returns a named vector of prefixes with
associated `Red` and `Grn` files, for `readIDATpair`:

```{r}
sdfs = lapply(searchIDATprefixes(system.file(
    "extdata/", package = "sesameData")), readIDATpair)
```

which returns a list of "SigDF"s.

# $\beta$ Value Extraction

DNA methylation level (aka the $\beta$ values) are defined as
$$\beta = M / (M+U)$$

$M$ represents the signal from methylated allele and $U$ represents the
unmethylated allele.  It can be retrieved calling the `getBetas` function on
the `SigDF`.  The output is a named vector with probe ID as names.  For
example, the following commands read in one sample and convert it to $\beta$
values.

```{r}
betas = getBetas(sdf) # retrieve beta values
head(betas)
```

**CRITICAL:** `getBetas` takes a single `SigDF`
object as input instead of a list of them. A common mistake is to `c`-merge
multiple `SigDF`s. To combine multiple `SigDF`s, one can use `list()` instead.
To have it process many `SigDF`s, we
should combine that with looping functions `lapply` or `mclapply`s, or using
the `openSesame` pipeline (see below).

# Sum Two Channels

$\beta$ values for Infinium-I probes can also be obtained by summing up the two
in-band channel and out-of-band channel. This rescues probes with SNP hitting
the extension base and hence switching color channel. More details can be
found in
[Zhou et al 2017](https://academic.oup.com/nar/article/45/4/e22/2290930).
```{r}
library(sesame)
## show case using an example without mask, then add mask with qualityMask
sdf = qualityMask(sesameDataGet('EPIC.1.SigDF'))
betas = getBetas(sdf, sum.TypeI = TRUE)
```

Extra SNP allele frequencies can be obtained by summing up methylated and
umethylated alleles of color-channel-switching probes. These allele frequencies
can be combined with explicit SNP probes:

```{r}
head(getAFs(sdf)) # combined
head(getAFTypeIbySumAlleles(sdf)) # AFs from only color-channel-switching
```

# Masking

If you call getBetas as is, you may have noticed that some of the beta values
show up having NA values. This NA-masking is controlled internally using the
`mask` column in `SigDF`. To check probes to be NA-masked in a `SigDF`, one can
use the `mask` function

```{r}
head(sdf$mask)
sum(sdf$mask)   # number of probes to be NA-masked
sum(is.na(betas)) # should be the same as above
```

Please note that `mask` in `SigDF` does not actually remove the probe reading
but only specify how SeSAMe currently views the measurement (as
unreliable). One can add more probes to the mask with the `addMask`
function. Other functions such as the detection p-value calculation, also
modifies `mask`. NA-masking influences other normalization and preprocessing
functions. Therefore one should have them set for the preprocessing methods
mentioned below. If one does not do any explicit masking, one simply gets the
masking specified in the `mask` column of the manifest. This defines the
default masking behavior of SeSAMe. For more details of masking, one can refer
to [Zhou et al 2017](https://academic.oup.com/nar/article/45/4/e22/2290930).
One can override this masking by the `resetMask` function

```{r}
sum(sdf$mask)  # before resetting
sum(resetMask(sdf)$mask)  # after resetting, expect 0
```

The `getBetas` function can also ignore NA-masking while extracting beta
values:

```{r}
sum(is.na(getBetas(sdf, mask=FALSE)))  # expect 0
```

We recommend two types of probe masking:

1) **Experiment-dependent Probe Masking** based on signal detection p-value
([Zhou et al. 2018](https://www.ncbi.nlm.nih.gov/pubmed/30085201)). Probes with
p-value higher than a threshold (default: 0.05) are masked (see following for
detection p-value calculation using the `pOOBAH` method).

2) **Experiment-independent Probe Masking** due to design issues. This is
typically designated in the `mask` column of the manifest (see 
[Zhou et al. 2017](https://www.ncbi.nlm.nih.gov/pubmed/27924034)): This masking
supports EPIC, MM285, HM450 and HM27 and is turned on by default and can also be
explicitly added by the function `qualityMask`.

# Detection P-value

As mentioned above, experiment-dependent masking based on signal detection
p-values is effective in excluding artifactual methylation level reading
and probes with too much influence from signal background. We recommend the
`pOOBAH` algorithm that was based on Infinium-I probe out-of-band signal for
calibrating the distribution of the signal background:

```{r}
sum(sdf$mask)  # before pOOBAH, only quality mask
sum(pOOBAH(sdf)$mask) # after pOOBAH, expect more probes
sum(pOOBAH(resetMask(sdf))$mask) # pOOBAH-only masking
```

Sometimes one would want to calculation detection p-value without modifying the
mask.  For example, one may want to upload the p-values to GEO separately. In
those cases one can use the `return.pval` option and add pvalue-based mask
later.

```{r}
pvals = pOOBAH(sdf, return.pval=TRUE)
sdf2 = addMask(sdf, pvals > 0.05) # default, recommend between 0.05 and 0.2
```

# Background Subtraction

SeSAMe implements the
background subtraction based on normal-exponential deconvolution using
out-of-band probes `noob`
([Triche et al. 2013](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3627582/))
and optionally with extra bleed-through subtraction. Signal bleed-through
happens when measurement from one channel affects the measurement in the other
channel. SeSAMe's `noob` further removes residual background by regressing
out the green-to-red and red-to-green relationship using Type-I probes.
```{r}
sdf.nb = noob(sdf)          # noob background subtraction
sdf.sb = scrub(sdf)         # more aggressive background subtraction
```

One can use following beta to total signal intensity to check the effect of
background subtraction.
```{r fig.width=5}
sesameQC_plotIntensVsBetas(sdf)
sesameQC_plotIntensVsBetas(sdf.nb) # with noob
```

# Dye Bias Correction

Dye bias refers to the difference in signal intensity between the two color
channel. SeSAMe offers two flavors of dye bias correction: linear scaling
(`dyeBiasCorr`) and nonlinear scaling (`dyeBiasCorrTypeINorm`). Linear scaling
equalize the mean of all probes from the two color channel.
```{r fig.width=5}
library(sesame)
sdf.dbLinear = dyeBiasCorr(sdf)
sesameQC_plotRedGrnQQ(sdf.dbLinear)
```

Residual dye bias can be corrected using nonlinear quantile interpolation with
Type-I probes.
```{r}
sdf.dbNonlinear = dyeBiasNL(sdf)
```
Under this correction, Infinium-I Red probes and
Infinium-I Grn probes have the same distribution of signal.
```{r fig.width=5}
sesameQC_plotRedGrnQQ(sdf.dbNonlinear)
```

Note that linear scaling does not shift beta values of Type-I probes while
nonlinear scaling does shift beta values of Type-I probes.

# Channel Inference

Sometimes Infinium-I channel spec is inaccurate in the manifest. We can
infer the channel from data.

```{r}
sdf.InfICorrected = inferInfiniumIChannel(sdf, verbose=TRUE)
```

As one can see, most probes remain with the designated channel. A small
fraction of the probes is considered "channel-switching".

# The openSesame Pipeline

Put together, the noob, nonlinear dye bias correction and pOOBAH can be chained
as follows into a pipeline and called in parallel (showing 2 cores below):

```{r eval = FALSE}
idat_dir = system.file("extdata/", package = "sesameData")
betas = do.call(cbind, mclapply(searchIDATprefixes(idat_dir), function(pfx) {
    getBetas(dyeBiasNL(noob(pOOBAH(readIDATpair(pfx)))))
}), mc.cores=2)
```

Equivalently, sesame provides the **openSesame** pipeline

```{r eval = FALSE}
idat_dir = system.file("extdata/", package = "sesameData")
betas = openSesame(idat_dir)
```

as a quickstart alias. Here `idat_dir` is the directory containing all the IDAT
files. Multi-core processing can be specified using the BiocParallel package:

```{r eval = FALSE}
betas = openSesame(idat_dir, BPPARAM=BiocParallel::MulticoreParam(2))
```

Like readIDATpair, `openSesame` also works with custom-made array with a
manifest file (see above):

```{r eval = FALSE}
betas = openSesame(idat_dir, manifest = manifest)
```

# The SigDF Class

SeSAMe design includes alight-weight full exposure of internal signal
intensities (essential information for users of Illumina methylation array data,
as demonstrated in Zhou et al 2018), which permits sensitive and specific joint
inference on copy number and DNA methylation.

Central to the SeSAMe platform is the `SigDF` data structure,
a `data.frame` subclass with the following column names

```{r}
colnames(sdf)
```

The `col` column specifies the color channel and takes `G`, `R` and `2`.
The Infinium-I probes carry `G` and `R`
```{r}
head(sdf[sdf$col != "2",])      # Infinium-I probes
head(sdf[sdf$col == "2",])      # Infinium-II probes
```

The `controls` attributes may contain the control probe information. The
control probe annotation can be found using the following function:

```{r}
head(controls(sdf))
```

For control probes, signal intensities are stored as an `Nx2` numeric
matrix, with `N` representing the number of probes in the class. The two
columns of the matrix represent the methylated probe intensity and the 
unmethylated probe intensity.

# SigDF to/from tsv/csv

`SigDF` can be written as and read from plain text file with the compliant
column names (i.e., `r colnames(sdf)`).

```{r}
tsv_file_path = sprintf("%s/sigdf.tsv", tempdir())
sdf_write_table(sdf, file=tsv_file_path, sep="\t", quote=FALSE) # save as tsv
sdf2 = sdf_read_table(tsv_file_path)                            # read back

csv_file_path = sprintf("%s/sigdf.csv", tempdir())
sdf_write_table(sdf, file=csv_file_path, sep=",") # save as csv
sdf2 = sdf_read_table(csv_file_path, sep=",")     # read back
```

# External Interactions

Previously, the signal was implemented an S4 implementation in `SigSet`
complies with Bioconductor guidelines, and for backwards compatibility,
`SigSet` can be transformed to a `SigDF` using the `SigSetToSigDF` function
`sesame:::SigSetToSigDF(sset)`.

`SigSet`/`SigDF` can be converted back and forth from Minfi `RGChannelSet` in
multiple ways. One can sesamize a minfi `RGChannelSet` which returns a
`GenomicRatioSet`.  See [sesamize](https://github.com/zwdzwd/sesamize) for more
detail.

# Session Info

```{r}
sessionInfo()
```
