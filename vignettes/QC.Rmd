---
title: "Quality Control"
date: "`r BiocStyle::doc_date()`"
package: sesame
output: BiocStyle::html_document
fig_width: 6
fig_height: 6
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{1. Quality Control}
  %\VignetteEncoding{UTF-8}
---

```{r message=FALSE, results="hide"}
library(sesame)
sesameDataCacheAll()
```

# Calculate quality metrics

The central function to calculate the quality metrics is `sesameQC_calcStats`.
SeSAMe divides sample quality metrics into multiple groups. Each group of
quality metrics can be generated using a dedicated function. All these
functions can be accessed through the `sesameQC_calcStats`
function. `sesameQC_calcStats()` calculates QC stats of one SigDF and returns a
single object of the class `sesameQC`.

```{r}
sdf <- sesameDataGet('EPIC.1.SigDF')
sesameQC_calcStats(sdf)
```

The choice of QC metrics depends on the 2nd argument of the
`sesameQC_calcStats` function. This argument is optional and can take one or a
list of the following keys. For example, "intensity" generates signal intensity
related quality metrics. By default, all stats will be calculated. The
following demonstrates the use of these functions. We consider signal detection
the most important QC metric.

```{r echo=FALSE}
library(knitr)
kable(data.frame(
    "Short Key" = c(
        "detection",
        "numProbes",
        "intensity",
        "channel",
        "dyeBias",
        "betas"),
    "Description" = c(
        "Signal Detection",
        "Number of Probes",
        "Signal Intensity",
        "Color Channel",
        "Dye Bias",
        "Beta Value")))
```

One can calculate specific group(s) of metrics by giving the 2nd argument: e.g.,

```{r}
qc <- sesameQC_calcStats(sdf, c("dyeBias", "detection"))
qc
```

The `sesameQC_calcStats` function returns an S4 `sesameQC` object. One can retrieve the actual stats using the sesameQC_getStats

```{r}
sesameQC_getStats(qc, "frac_dt")
```

One can combine multiple sesameQC into a data frame:

```{r}
sdfs <- sesameDataGet("EPIC.5.SigDF.normal")
df <- do.call(rbind, lapply(sdfs, function(sdf)
   as.data.frame(sesameQC_calcStats(sdf, "detection"))))
head(df)
```

# Rank quality metrics

```{r echo=FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
```

SeSAMe features functions to compare your sample with public data sets. The
`sesameQC_rankStats()` function rank the input `sesameQC` object with
`sesameQC` calculated from public datasets. It shows the rank percentage of the
input sample as well as the number of datasets compared.

```{r}
sdf <- sesameDataGet('EPIC.1.SigDF')
qc <- sesameQC_calcStats(sdf, "intensity")
qc
sesameQC_rankStats(qc, platform="EPIC")
```

# Quality control plots

## QC Stats Bar plot

SeSAMe provides functions to create QC plots. Some functions takes sesameQC as
input while others directly plots the SigDF objects. For example, the
`sesameQC_plotBar` function takes a list of sesameQC objects and creates bar
plot for each metric calculated.

The fraction of detection failures are signs of masking due to variety of
reasons including failed detection, high background, putative low quality
probes etc. To compare samples in terms of detection success rate, one can use
the `sesameQC_plotBar` function in the following way:

```{r fig.height=15, fig.width=5}
sesameQC_plotBar(lapply(sdfs, sesameQC_calcStats))
```

## Dye bias Q-Q plot

Dye bias is shown by an off-diagonal q-q plot of the red (x-axis) and green
signal (y-axis).

```{r fig.height=5, fig.width=5, fig.align="center"}
sesameQC_plotRedGrnQQ(sdf)
```

## Intensity-beta plot

Beta value is more influenced by signal background for probes with low signal
intensities. The following plot shows this dependency and the extent of probes
with low signal intensity.

```{r fig.height=5, fig.width=5, fig.align="center"}
sesameQC_plotIntensVsBetas(sdf)
```

# Genotype validation

SeSAMe can extract explicit and Infinium-I-derived SNPs to identify potential
sample swaps.

```{r fig.height=5, fig.width=5, fig.align="center", message=FALSE}
sesameQC_plotHeatSNPs(sdfs)
```

One can also output the allele frequencies and output a VCF file with
genotypes. This requires additional SNP information (ref and alt alleles),
which can be downloaded using the following code:

```{r message=FALSE, results="hide"}
annoS <- sesameDataGetAnno("EPIC/EPIC.hg19.snp_overlap_b151.rds")
annoI <- sesameDataGetAnno("EPIC/EPIC.hg19.typeI_overlap_b151.rds")
```

```{r}
head(formatVCF(sdf, annoS=annoS, annoI=annoI))
```

One can output to actual VCF file with a header by `formatVCF(sdf,
vcf=path_to_vcf)`.

# Bisulfite conversion

Infinium platforms are intrinsically robust to incomplete bisulfite conversion
as non-converted probes would fail to hybridize to the target. Residual
incomplete bisulfite conversion can be quantified using GCT score based on
C/T-extension probes. Details of this method can be found in
[Zhou et al. 2017](https://academic.oup.com/nar/article/45/4/e22/2290930).
The closer the score to 1.0, the more complete the bisulfite conversion.

```{r}
sdf <- sesameDataGet('EPIC.1.SigDF')
bisConversionControl(sdf)
```

# Session Info

```{r}
sessionInfo()
```